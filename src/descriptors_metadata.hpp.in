#ifndef __LIBARCSDEC_DESCRIPTORS_METADATA_HPP__
#define __LIBARCSDEC_DESCRIPTORS_METADATA_HPP__

/**
 * \file
 *
 * \brief Provide compiled-in
 * @link MetadataParserDescriptor MetadataParserDescriptors @endlink.
 *
 * This information is controlled by cmake. It is made accessible at build time
 * for program scope.
 */

#include <memory>
#include <vector>

#ifndef __LIBARCSDEC_PARSERCUE_HPP__
#include "parsercue.hpp"
#endif


namespace arcsdec
{

inline namespace v_1_0_0
{

/**
 * \brief List of supported audio file formats.
 *
 * The actual list entries are controlled by CMake at buildtime.
 *
 * \internal
 * \ingroup metaparser
 */
class FileReaderDescriptorsMetadata final
{
	using container_type = std::vector<std::unique_ptr<FileReaderDescriptor>>;


public:

	using iterator = container_type::iterator;

	using const_iterator = container_type::const_iterator;

	/**
	 * \brief Default constructor.
	 *
	 * Adds all available formats to the instance.
	 */
	FileReaderDescriptorsMetadata()
		: formats_()
	{
		formats_.reserve(2);

		formats_.push_back(std::make_unique<DescriptorCUE>());
	}

	/**
	 * \brief Iterator pointing to the first format.
	 */
	iterator begin()
	{
		return formats_.begin();
	}

	/**
	 * \brief Iterator pointing behind the last format.
	 */
	iterator end()
	{
		return formats_.end();
	}

	/**
	 * \brief Iterator pointing to the first format.
	 */
	const_iterator begin() const
	{
		return formats_.begin();
	}

	/**
	 * \brief Iterator pointing behind the last format.
	 */
	const_iterator end() const
	{
		return formats_.end();
	}

	/**
	 * \brief Iterator pointing to the first format.
	 */
	const_iterator cbegin() const
	{
		return formats_.cbegin();
	}

	/**
	 * \brief Iterator pointing behind the last format.
	 */
	const_iterator cend() const
	{
		return formats_.cend();
	}


private:

	/**
	 * \brief List of available file formats.
	 */
	container_type formats_;
};

} // namespace v_1_0_0

} // namespace arcsdec

#endif

